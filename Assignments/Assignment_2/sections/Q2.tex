\section{Bottom-\textit{k} sampling}
\subsection{Frequency Estimation}
\subsubsection{Exercise 2}

We are asked to show that \(E\left[ | C \cap S_h^k(A)| / k\right]  = |C|/|A|\). 

We are told that \(S_h^k(A)\) is a uniformly random subset of A and C is a subset of A which is independent from \(S_h^k(A)\), knowing these we can say 

\begin{align}
&Pr\left[x \in S_h^k(A)\right] = p = \frac{k}{|A|}  \label{fact:prob_shk}\\
&Pr\left[x \in C \right] = Pr(C) = \frac{|C|}{|A|}  \label{fact:prob_C}
\end{align}


\begin{align*}
  & {E}\left[ | C \cap S_h^k(A) | / k \right] & \\
  &= \frac{1}{k} \cdot {E}\left[ | C \cap S_h^k(A) |\right] & \\
  &= \frac{1}{k} \sum_{a\in A} {E}\left[ a \in C \land a \in S_h^k(A) \right] & \\
  &= \frac{1}{k}\sum_{a\in A} Pr\left[ a \in C \land a \in S_h^k(A) \right] & \\
  &= \frac{1}{k}\sum_{a\in A} \left( Pr\left[ a \in C \right] \cdot Pr\left[ a \in S_h^k(A) \right] \right) 
  & \quad \text{Independence} \\
  &= \frac{1}{k} \cdot \sum_{a\in A} \left( \frac{|C|}{|A|} \cdot \frac{k}{|A|} \right) & \quad \text{From \ref{fact:prob_shk} and \ref{fact:prob_C}} \\
  &= \frac{1}{k} \cdot \frac{|C|}{|A|} \cdot \frac{k}{|A|} \cdot \sum_{a\in A} 1 
  & \quad \text{Elements in summation independent of \(a \in A\)} \\
  &= \frac{1}{k} \cdot \frac{|C|}{|A|} \cdot k & \\
  &= \frac{|C|}{|A|} & 
\end{align*}

\subsubsection{Exercise 3 (a)}
When implementing the hashes we would consider what the greater need is, whether the need is to store or retrieve. The reason this is relevant is that, if the primary need is to retrieve, then we would opt to use a binary tree given that the worst case search time is \(O\log_2(h)\) for a balanced tree, whereas it's \(O(h)\) for an unbalanced tree, where h is the height. For inserting the running time is the same as for searching, under the same conditions.\\
If the primary interest is to insert and store we would instead use a linked list or a stack as insertion into those data structure is \(O(1)\).\\
\subsubsection{Exercise 3 (b)}
As mentioned, processing and inserting the key \(x_{i+1}\) would take at worst \(O(h)\) using binary trees, whereas it would take \(O(1)\) for both stacks and lists.
\subsection{Similarity Estimation}
\subsubsection{Exercise 4}
We will use the definition of \(S_h^k \) to prove \(4(a)\) analytically. \(S_h^k(A) = \{\text{the } k \text{ keys } x \in A \text{ with the smallest hash values}\} \)
